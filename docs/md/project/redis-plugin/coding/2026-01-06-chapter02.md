---
title: 第02节：高性能Redis组件分布式锁设计与实现
pay: https://articles.zsxq.com/id_r6stemvv0www.html
---

# 《高性能Redis组件》落地实现-第02节：高性能Redis组件分布式锁设计与实现

作者：冰河
<br/>星球：[http://m6z.cn/6aeFbs](http://m6z.cn/6aeFbs)
<br/>博客：[https://binghe.gitcode.host](https://binghe.gitcode.host)
<br/>文章汇总：[https://binghe.gitcode.host/md/all/all.html](https://binghe.gitcode.host/md/all/all.html)
<br/>源码获取地址：[https://t.zsxq.com/0dhvFs5oR](https://t.zsxq.com/0dhvFs5oR)

> 沉淀，成长，突破，帮助他人，成就自我。

* 本章难度：★☆☆☆☆
* 本章重点：对高性能Redis组件的分布式锁进行设计和实现，从总体上理解高性能Redis组件分布式锁的设计，并从全局视角了解高性能Redis组件的设计和架构思想，并能够将其灵活应用到自身实际项目中。

**大家好，我是冰河~~**

高性能缓存组件可以让业务无需过多关注与Redis交互的细节即可接入Redis，如果数据过期，高性能Redis组件会怎么处理？异步查询DB构建缓存数据。查询DB时，如何防止所有流量打到DB呢？在异步线程中使用分布式锁保证只有获取到锁的线程访问DB，并且在访问地址之前，会再次查询缓存是否存在数据，如果缓存存在数据，并且数据并未在逻辑上过期，则使用缓存数据。否则，才会查询DB重新构建缓存数据。通过分布式锁+二次校验的方式确保同一时刻只有一个线程访问DB。

## 一、前言

高性能Redis组件的性能之所以高，是因为绝大部分流量直接查询缓存即可返回数据，在设计上就不存在缓存击穿、穿透和雪崩问题。当缓存中的数据为空时，就需要异步构建缓存数据。为了在同一时刻只有一个异步线程执行构建缓存的逻辑。此时，分布式锁就派上了用场。

## 二、本节诉求

对高性能Redis组件的分布式锁进行设计和实现，从总体上理解高性能Redis组件基础功能的设计，并从全局视角了解高性能Redis组件的设计和架构思想，并能够将其灵活应用到自身实际项目中。

## 三、核心类设计

**注意：本节只给大家展示高性能Redis组件分布式锁的核心类实现关系，其他代码的实现细节，大家可以自行到本节对应的源码分支进行查看，这里不再赘述。**

高性能Redis组件分布式锁的核心类设计如图2-1所示。

<div align="center">
    <img src="https://binghe.gitcode.host/images/project/redis-plugin/2026-01-04-002.png?raw=true" width="70%">
    <br/>
</div>

可以看到，高性能Redis组件的分布式锁主要由DistributedLock接口、DistributedLockFactory接口、RedissonLockFactory实现类组成。

* DistributedLock接口：分布式锁的核心接口，主要定义了加锁和释放锁等的相关方法。
* DistributedLockFactory接口：分布式锁的工厂接口，依赖DistributedLock接口，通过工厂接口可获取对应的分布式锁对象。
* RedissonLockFactory实现类：分布式锁的工厂实现类，实现了DistributedLockFactory接口，并通过匿名方式实现了DistributedLock接口的所有方法。

## 四、编码实现

本节只给大家展示高性能Redis组件分布式锁的核心类编码实现，其他代码的实现细节，大家可以自行到本节对应的源码分支进行查看，这里不再赘述。

**（1）实现DistributedLock接口**

DistributedLock接口是分布式锁的核心接口，主要定义了加锁和释放锁等的相关方法。

源码详见：io.binghe.redis.plugin.lock.DistributedLock。

```java
public interface DistributedLock {

    boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException;

    boolean tryLock(long waitTime,  TimeUnit unit) throws InterruptedException;

    boolean tryLock() throws InterruptedException;

    void lock(long leaseTime, TimeUnit unit);

    void unlock();

    boolean isLocked();

    boolean isHeldByThread(long threadId);

    boolean isHeldByCurrentThread();
}
```

**（2）实现DistributedLockFactory接口**

DistributedLockFactory接口是分布式锁的工厂接口，依赖DistributedLock接口，通过工厂接口可获取对应的分布式锁对象。

源码详见：io.binghe.redis.plugin.lock.factory.DistributedLockFactory。

```java
public interface DistributedLockFactory {

    /**
     * 根据key获取分布式锁
     */
    DistributedLock getDistributedLock(String key);
}
```

**（3）实现RedissonLockFactory类**

RedissonLockFactory类是分布式锁的工厂实现类，实现了DistributedLockFactory接口，并通过匿名方式实现了DistributedLock接口的所有方法。

源码详见：io.binghe.redis.plugin.lock.redisson.RedissonLockFactory。

## 查看完整文章

加入[冰河技术](https://public.zsxq.com/groups/48848484411888.html)知识星球，解锁完整技术文章、小册、视频与完整代码